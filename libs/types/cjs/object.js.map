{"version":3,"sources":["../lib/object.js"],"sourcesContent":["import _each from 'lodash/each';\nimport { ValidationError } from './errors';\nimport { Types, safeJsonStringify, beginSanitize } from './types';\nimport { makePath } from '@galaxar/utils/objectPathUtils';\nimport isPlainObject from '@galaxar/utils/isPlainObject';\n\nconst jsonStarter = new Set(['\"', '[', '{']);\nconst jsonEnding = {\n    '\"': '\"',\n    '[': ']',\n    '{': '}',\n};\n\nexport default {\n    name: 'object',\n    alias: ['json'],\n    defaultValue: {},\n    validate: (value) => isPlainObject(value),\n    sanitize: (value, meta, i18n, path) => {\n        const [isDone, sanitized] = beginSanitize(value, meta, i18n, path);\n        if (isDone) return sanitized;\n\n        const raw = value;\n        const type = typeof value;\n\n        if (type === 'string') {\n            if (value.length > 1 && jsonStarter.has(value[0]) && jsonEnding[value[0]] === value[value.length - 1]) {\n                value = JSON.parse(value);\n            }\n        }\n\n        if (meta.schema) {\n            if (typeof value !== 'object') {\n                throw new ValidationError('Invalid object value.', {\n                    value: raw,\n                    meta,\n                    i18n,\n                    path,\n                });\n            }\n\n            const schema = typeof meta.schema === 'function' ? meta.schema() : meta.schema;\n            const newValue = {};\n            _each(schema, (validationObject, fieldName) => {\n                const fieldValue = value[fieldName];\n\n                const _fieldValue = Types.sanitize(fieldValue, validationObject, i18n, makePath(path, fieldName));\n                if (_fieldValue != null || (fieldName in value)) {\n                    newValue[fieldName] = _fieldValue;\n                }\n            });\n\n            if (meta.keepUnsanitized) {\n                return { ...value, ...newValue };\n            }\n\n            return newValue;\n        }\n\n        return value;\n    },\n\n    serialize: (value) => {\n        if (value == null) return null;\n        return safeJsonStringify(value);\n    },\n};\n"],"names":["jsonStarter","Set","jsonEnding","name","alias","defaultValue","validate","value","isPlainObject","sanitize","meta","i18n","path","isDone","sanitized","beginSanitize","raw","type","length","has","JSON","parse","schema","ValidationError","newValue","_each","validationObject","fieldName","fieldValue","_fieldValue","Types","makePath","keepUnsanitized","serialize","safeJsonStringify"],"mappings":";;;;+BAaA;;;eAAA;;;6DAbkB;wBACc;uBACwB;iCAC/B;sEACC;;;;;;AAE1B,MAAMA,cAAc,IAAIC,IAAI;IAAC;IAAK;IAAK;CAAI;AAC3C,MAAMC,aAAa;IACf,KAAK;IACL,KAAK;IACL,KAAK;AACT;MAEA,WAAe;IACXC,MAAM;IACNC,OAAO;QAAC;KAAO;IACfC,cAAc,CAAC;IACfC,UAAU,CAACC,QAAUC,IAAAA,sBAAa,EAACD;IACnCE,UAAU,CAACF,OAAOG,MAAMC,MAAMC,OAAS;QACnC,MAAM,CAACC,QAAQC,UAAU,GAAGC,IAAAA,oBAAa,EAACR,OAAOG,MAAMC,MAAMC;QAC7D,IAAIC,QAAQ,OAAOC;QAEnB,MAAME,MAAMT;QACZ,MAAMU,OAAO,OAAOV;QAEpB,IAAIU,SAAS,UAAU;YACnB,IAAIV,MAAMW,MAAM,GAAG,KAAKlB,YAAYmB,GAAG,CAACZ,KAAK,CAAC,EAAE,KAAKL,UAAU,CAACK,KAAK,CAAC,EAAE,CAAC,KAAKA,KAAK,CAACA,MAAMW,MAAM,GAAG,EAAE,EAAE;gBACnGX,QAAQa,KAAKC,KAAK,CAACd;YACvB,CAAC;QACL,CAAC;QAED,IAAIG,KAAKY,MAAM,EAAE;YACb,IAAI,OAAOf,UAAU,UAAU;gBAC3B,MAAM,IAAIgB,uBAAe,CAAC,yBAAyB;oBAC/ChB,OAAOS;oBACPN;oBACAC;oBACAC;gBACJ,GAAG;YACP,CAAC;YAED,MAAMU,SAAS,OAAOZ,KAAKY,MAAM,KAAK,aAAaZ,KAAKY,MAAM,KAAKZ,KAAKY,MAAM;YAC9E,MAAME,WAAW,CAAC;YAClBC,IAAAA,aAAK,EAACH,QAAQ,CAACI,kBAAkBC,YAAc;gBAC3C,MAAMC,aAAarB,KAAK,CAACoB,UAAU;gBAEnC,MAAME,cAAcC,YAAK,CAACrB,QAAQ,CAACmB,YAAYF,kBAAkBf,MAAMoB,IAAAA,yBAAQ,EAACnB,MAAMe;gBACtF,IAAIE,eAAe,IAAI,IAAKF,aAAapB,OAAQ;oBAC7CiB,QAAQ,CAACG,UAAU,GAAGE;gBAC1B,CAAC;YACL;YAEA,IAAInB,KAAKsB,eAAe,EAAE;gBACtB,OAAO;oBAAE,GAAGzB,KAAK;oBAAE,GAAGiB,QAAQ;gBAAC;YACnC,CAAC;YAED,OAAOA;QACX,CAAC;QAED,OAAOjB;IACX;IAEA0B,WAAW,CAAC1B,QAAU;QAClB,IAAIA,SAAS,IAAI,EAAE,OAAO,IAAI;QAC9B,OAAO2B,IAAAA,wBAAiB,EAAC3B;IAC7B;AACJ"}