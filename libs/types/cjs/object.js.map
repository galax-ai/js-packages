{"version":3,"sources":["../object.js"],"sourcesContent":["import _each from 'lodash/each';\nimport { ValidationError } from './errors';\nimport { Types, safeJsonStringify, beginSanitize } from './types';\nimport { makePath } from '@galaxar/utils/pathUtils';\nimport isPlainObject from '@galaxar/utils/isPlainObject';\n\nconst jsonStarter = new Set(['\"', '[', '{']);\nconst jsonEnding = {\n    '\"': '\"',\n    '[': ']',\n    '{': '}',\n};\n\nexport default {\n    name: 'object',\n    alias: ['json'],\n    defaultValue: {},\n    validate: value =>isPlainObject(value),\n    sanitize: (value, meta, i18n, path) => {\n        const [ isDone, sanitized ] = beginSanitize(value, meta, i18n, path);\n        if (isDone) return sanitized;\n\n        const raw = value;\n        const type = typeof value;\n\n        if (type === 'string') {\n            if (\n                value.length > 1 &&\n                jsonStarter.has(value[0]) &&\n                jsonEnding[value[0]] === value[value.length - 1]\n            ) {                                \n                value = JSON.parse(value);\n            }\n        }\n\n        if (meta.schema) {\n            if (typeof value !== 'object') {\n                throw new ValidationError('Invalid object value.', {\n                    value: raw,\n                    meta,\n                    i18n,\n                    path,\n                });\n            }\n\n            const schema = typeof meta.schema === 'function' ? meta.schema() : meta.schema;\n            const newValue = {};\n            _each(schema, (validationObject, fieldName) => {\n                const fieldValue = value[fieldName];\n                newValue[fieldName] = Types.sanitize(fieldValue, validationObject, i18n, makePath(path, fieldName));                \n            });\n\n            if (meta.keepUnsanitized) {\n                return { ...value, ...newValue };\n            }\n\n            return newValue;\n        }\n\n        return value;\n    },\n\n    serialize: (value) => {\n        if (value == null) return null;\n        return safeJsonStringify(value);\n    }\n};\n"],"names":["jsonStarter","Set","jsonEnding","name","alias","defaultValue","validate","value","isPlainObject","sanitize","meta","i18n","path","isDone","sanitized","beginSanitize","raw","type","length","has","JSON","parse","schema","ValidationError","newValue","_each","validationObject","fieldName","fieldValue","Types","makePath","keepUnsanitized","serialize","safeJsonStringify"],"mappings":";;;;+BAaA;;;eAAA;;;6DAbkB;wBACc;uBACwB;2BAC/B;sEACC;;;;;;AAE1B,MAAMA,cAAc,IAAIC,IAAI;IAAC;IAAK;IAAK;CAAI;AAC3C,MAAMC,aAAa;IACf,KAAK;IACL,KAAK;IACL,KAAK;AACT;MAEA,WAAe;IACXC,MAAM;IACNC,OAAO;QAAC;KAAO;IACfC,cAAc,CAAC;IACfC,UAAUC,CAAAA,QAAQC,IAAAA,sBAAa,EAACD;IAChCE,UAAU,CAACF,OAAOG,MAAMC,MAAMC,OAAS;QACnC,MAAM,CAAEC,QAAQC,UAAW,GAAGC,IAAAA,oBAAa,EAACR,OAAOG,MAAMC,MAAMC;QAC/D,IAAIC,QAAQ,OAAOC;QAEnB,MAAME,MAAMT;QACZ,MAAMU,OAAO,OAAOV;QAEpB,IAAIU,SAAS,UAAU;YACnB,IACIV,MAAMW,MAAM,GAAG,KACflB,YAAYmB,GAAG,CAACZ,KAAK,CAAC,EAAE,KACxBL,UAAU,CAACK,KAAK,CAAC,EAAE,CAAC,KAAKA,KAAK,CAACA,MAAMW,MAAM,GAAG,EAAE,EAClD;gBACEX,QAAQa,KAAKC,KAAK,CAACd;YACvB,CAAC;QACL,CAAC;QAED,IAAIG,KAAKY,MAAM,EAAE;YACb,IAAI,OAAOf,UAAU,UAAU;gBAC3B,MAAM,IAAIgB,uBAAe,CAAC,yBAAyB;oBAC/ChB,OAAOS;oBACPN;oBACAC;oBACAC;gBACJ,GAAG;YACP,CAAC;YAED,MAAMU,SAAS,OAAOZ,KAAKY,MAAM,KAAK,aAAaZ,KAAKY,MAAM,KAAKZ,KAAKY,MAAM;YAC9E,MAAME,WAAW,CAAC;YAClBC,IAAAA,aAAK,EAACH,QAAQ,CAACI,kBAAkBC,YAAc;gBAC3C,MAAMC,aAAarB,KAAK,CAACoB,UAAU;gBACnCH,QAAQ,CAACG,UAAU,GAAGE,YAAK,CAACpB,QAAQ,CAACmB,YAAYF,kBAAkBf,MAAMmB,IAAAA,mBAAQ,EAAClB,MAAMe;YAC5F;YAEA,IAAIjB,KAAKqB,eAAe,EAAE;gBACtB,OAAO;oBAAE,GAAGxB,KAAK;oBAAE,GAAGiB,QAAQ;gBAAC;YACnC,CAAC;YAED,OAAOA;QACX,CAAC;QAED,OAAOjB;IACX;IAEAyB,WAAW,CAACzB,QAAU;QAClB,IAAIA,SAAS,IAAI,EAAE,OAAO,IAAI;QAC9B,OAAO0B,IAAAA,wBAAiB,EAAC1B;IAC7B;AACJ"}