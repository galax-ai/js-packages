{"version":3,"sources":["../array.js"],"sourcesContent":["import { ValidationError } from \"./errors\";\nimport { Types, safeJsonStringify, getStringifier, beginSanitize } from \"./types\";\n\nimport csvLineParse from \"@galaxar/utils/csvLineParse\";\nimport arrayToCsv from \"@galaxar/utils/arrayToCsv\";\nimport { padLeft } from \"@galaxar/utils/padding\";\n\nconst T_ARRAY = {\n    name: \"array\",\n    alias: [\"list\"],\n    defaultValue: [],\n    validate: value => Array.isArray(value),\n    sanitize: (value, meta, i18n, path) => {\n        const [ isDone, sanitized ] = beginSanitize(value, meta, i18n, path);\n        if (isDone) return sanitized;\n\n        const raw = value;\n\n        if (typeof value === \"string\") {\n            if (meta.csv) {\n                value = csvLineParse(value, { delimiter: meta.delimiter || \",\" });\n            } else {\n                const trimmed = value.trim();\n                if (trimmed.startsWith(\"[\") && trimmed.endsWith(\"]\")) {\n                    value = JSON.parse(trimmed);\n                }\n            }\n        }\n\n        if (Array.isArray(value)) {\n            if (meta.elementSchema) {\n                const schema =\n                    typeof meta.elementSchema === \"function\" ? meta.elementSchema() : meta.elementSchema;\n\n                return value.map((a, i) => Types.sanitize(a, schema, i18n, padLeft(`[${i}]`, path)));\n            }\n\n            return value;\n        }\n\n        throw new ValidationError(\"Invalid array value.\", {\n            value: raw,\n            meta,\n            i18n,\n            path\n        });\n    },\n    serialize: (value, typeInfo) =>\n        value == null ? null : typeInfo?.csv ? arrayToCsv(value, typeInfo?.delimiter, getStringifier()) : safeJsonStringify(value),\n};\n\nexport default T_ARRAY;\n"],"names":["T_ARRAY","name","alias","defaultValue","validate","value","Array","isArray","sanitize","meta","i18n","path","isDone","sanitized","beginSanitize","raw","csv","csvLineParse","delimiter","trimmed","trim","startsWith","endsWith","JSON","parse","elementSchema","schema","map","a","i","Types","padLeft","ValidationError","serialize","typeInfo","arrayToCsv","getStringifier","safeJsonStringify"],"mappings":"oGAmDA,iDAAA,kCAnDgC,iCACwC,gEAE/C,mFACF,qDACC,8GAExB,MAAMA,QAAU,CACZC,KAAM,QACNC,MAAO,CAAC,OAAO,CACfC,aAAc,EAAE,CAChBC,SAAUC,OAASC,MAAMC,OAAO,CAACF,OACjCG,SAAU,CAACH,MAAOI,KAAMC,KAAMC,OAAS,CACnC,KAAM,CAAEC,OAAQC,UAAW,CAAGC,GAAAA,oBAAa,EAACT,MAAOI,KAAMC,KAAMC,MAC/D,GAAIC,OAAQ,OAAOC,SAAU,CAE7B,MAAME,IAAMV,MAEZ,GAAI,OAAOA,QAAU,SAAU,CAC3B,GAAII,KAAKO,GAAG,CAAE,CACVX,MAAQY,GAAAA,qBAAY,EAACZ,MAAO,CAAEa,UAAWT,KAAKS,SAAS,EAAI,GAAI,EACnE,KAAO,CACH,MAAMC,QAAUd,MAAMe,IAAI,GAC1B,GAAID,QAAQE,UAAU,CAAC,MAAQF,QAAQG,QAAQ,CAAC,KAAM,CAClDjB,MAAQkB,KAAKC,KAAK,CAACL,QACvB,CAAC,AACL,CAAC,AACL,CAAC,AAED,GAAIb,MAAMC,OAAO,CAACF,OAAQ,CACtB,GAAII,KAAKgB,aAAa,CAAE,CACpB,MAAMC,OACF,OAAOjB,KAAKgB,aAAa,GAAK,WAAahB,KAAKgB,aAAa,GAAKhB,KAAKgB,aAAa,CAExF,OAAOpB,MAAMsB,GAAG,CAAC,CAACC,EAAGC,IAAMC,YAAK,CAACtB,QAAQ,CAACoB,EAAGF,OAAQhB,KAAMqB,GAAAA,gBAAO,EAAC,CAAC,CAAC,EAAEF,EAAE,CAAC,CAAC,CAAElB,OACjF,CAAC,AAED,OAAON,KACX,CAAC,AAED,MAAM,IAAI2B,uBAAe,CAAC,uBAAwB,CAC9C3B,MAAOU,IACPN,KACAC,KACAC,IACJ,EAAG,AACP,EACAsB,UAAW,CAAC5B,MAAO6B,WACf7B,OAAS,IAAI,CAAG,IAAI,CAAG6B,UAAUlB,IAAMmB,GAAAA,mBAAU,EAAC9B,MAAO6B,UAAUhB,UAAWkB,GAAAA,qBAAc,KAAMC,GAAAA,wBAAiB,EAAChC,MAAM,AAClI,QAEA,SAAeL"}