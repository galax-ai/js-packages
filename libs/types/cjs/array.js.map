{"version":3,"sources":["../array.js"],"sourcesContent":["import { ValidationError } from \"./errors\";\nimport { Types, safeJsonStringify, getStringifier, beginSanitize } from \"./types\";\n\nimport csvLineParse from \"@galaxar/utils/csvLineParse\";\nimport arrayToCsv from \"@galaxar/utils/arrayToCsv\";\nimport { padLeft } from \"@galaxar/utils/padding\";\n\nconst T_ARRAY = {\n    name: \"array\",\n    alias: [\"list\"],\n    defaultValue: [],\n    validate: value => Array.isArray(value),\n    sanitize: (value, meta, i18n, path) => {\n        const [ isDone, sanitized ] = beginSanitize(value, meta, i18n, path);\n        if (isDone) return sanitized;\n\n        const raw = value;\n\n        if (typeof value === \"string\") {\n            if (meta.csv) {\n                value = csvLineParse(value, { delimiter: meta.delimiter || \",\" });\n            } else {\n                const trimmed = value.trim();\n                if (trimmed.startsWith(\"[\") && trimmed.endsWith(\"]\")) {\n                    value = JSON.parse(trimmed);\n                }\n            }\n        }\n\n        if (Array.isArray(value)) {\n            if (meta.elementSchema) {\n                const schema =\n                    typeof meta.elementSchema === \"function\" ? meta.elementSchema() : meta.elementSchema;\n\n                return value.map((a, i) => Types.sanitize(a, schema, i18n, padLeft(`[${i}]`, path)));\n            }\n\n            return value;\n        }\n\n        throw new ValidationError(\"Invalid array value.\", {\n            value: raw,\n            meta,\n            i18n,\n            path\n        });\n    },\n    serialize: (value, typeInfo) =>\n        value == null ? null : typeInfo?.csv ? arrayToCsv(value, typeInfo?.delimiter, getStringifier()) : safeJsonStringify(value),\n};\n\nexport default T_ARRAY;\n"],"names":["T_ARRAY","name","alias","defaultValue","validate","value","Array","isArray","sanitize","meta","i18n","path","isDone","sanitized","beginSanitize","raw","csv","csvLineParse","delimiter","trimmed","trim","startsWith","endsWith","JSON","parse","elementSchema","schema","map","a","i","Types","padLeft","ValidationError","serialize","typeInfo","arrayToCsv","getStringifier","safeJsonStringify"],"mappings":";;;;+BAmDA;;;eAAA;;;wBAnDgC;uBACwC;qEAE/C;mEACF;yBACC;;;;;;AAExB,MAAMA,UAAU;IACZC,MAAM;IACNC,OAAO;QAAC;KAAO;IACfC,cAAc,EAAE;IAChBC,UAAUC,CAAAA,QAASC,MAAMC,OAAO,CAACF;IACjCG,UAAU,CAACH,OAAOI,MAAMC,MAAMC,OAAS;QACnC,MAAM,CAAEC,QAAQC,UAAW,GAAGC,IAAAA,oBAAa,EAACT,OAAOI,MAAMC,MAAMC;QAC/D,IAAIC,QAAQ,OAAOC;QAEnB,MAAME,MAAMV;QAEZ,IAAI,OAAOA,UAAU,UAAU;YAC3B,IAAII,KAAKO,GAAG,EAAE;gBACVX,QAAQY,IAAAA,qBAAY,EAACZ,OAAO;oBAAEa,WAAWT,KAAKS,SAAS,IAAI;gBAAI;YACnE,OAAO;gBACH,MAAMC,UAAUd,MAAMe,IAAI;gBAC1B,IAAID,QAAQE,UAAU,CAAC,QAAQF,QAAQG,QAAQ,CAAC,MAAM;oBAClDjB,QAAQkB,KAAKC,KAAK,CAACL;gBACvB,CAAC;YACL,CAAC;QACL,CAAC;QAED,IAAIb,MAAMC,OAAO,CAACF,QAAQ;YACtB,IAAII,KAAKgB,aAAa,EAAE;gBACpB,MAAMC,SACF,OAAOjB,KAAKgB,aAAa,KAAK,aAAahB,KAAKgB,aAAa,KAAKhB,KAAKgB,aAAa;gBAExF,OAAOpB,MAAMsB,GAAG,CAAC,CAACC,GAAGC,IAAMC,YAAK,CAACtB,QAAQ,CAACoB,GAAGF,QAAQhB,MAAMqB,IAAAA,gBAAO,EAAC,CAAC,CAAC,EAAEF,EAAE,CAAC,CAAC,EAAElB;YACjF,CAAC;YAED,OAAON;QACX,CAAC;QAED,MAAM,IAAI2B,uBAAe,CAAC,wBAAwB;YAC9C3B,OAAOU;YACPN;YACAC;YACAC;QACJ,GAAG;IACP;IACAsB,WAAW,CAAC5B,OAAO6B,WACf7B,SAAS,IAAI,GAAG,IAAI,GAAG6B,UAAUlB,MAAMmB,IAAAA,mBAAU,EAAC9B,OAAO6B,UAAUhB,WAAWkB,IAAAA,qBAAc,OAAMC,IAAAA,wBAAiB,EAAChC,MAAM;AAClI;MAEA,WAAeL"}