{"version":3,"sources":["../array.js"],"sourcesContent":["import { ValidationError } from './errors';\nimport { Types, safeJsonStringify, getStringifier, beginSanitize } from './types';\n\nimport csvLineParse from '@galaxar/utils/csvLineParse';\nimport arrayToCsv from '@galaxar/utils/arrayToCsv';\nimport { padLeft } from '@galaxar/utils/padding';\n\nconst T_ARRAY = {\n    name: 'array',\n    alias: ['list'],\n    defaultValue: [],\n    validate: (value) => Array.isArray(value),\n    sanitize: (value, meta, i18n, path) => {\n        const [isDone, sanitized] = beginSanitize(value, meta, i18n, path);\n        if (isDone) return sanitized;\n\n        const raw = value;\n\n        if (typeof value === 'string') {\n            if (meta.csv) {\n                value = csvLineParse(value, { delimiter: meta.delimiter || ',' });\n            } else {\n                const trimmed = value.trim();\n                if (trimmed.startsWith('[') && trimmed.endsWith(']')) {\n                    value = JSON.parse(trimmed);\n                }\n            }\n        }\n\n        if (Array.isArray(value)) {\n            if (meta.elementSchema) {\n                const schema = typeof meta.elementSchema === 'function' ? meta.elementSchema() : meta.elementSchema;\n\n                return value.map((a, i) => Types.sanitize(a, schema, i18n, padLeft(`[${i}]`, path)));\n            }\n\n            return value;\n        }\n\n        throw new ValidationError('Invalid array value.', {\n            value: raw,\n            meta,\n            i18n,\n            path,\n        });\n    },\n    serialize: (value, typeInfo) =>\n        value == null\n            ? null\n            : typeInfo?.csv\n            ? arrayToCsv(value, typeInfo?.delimiter, getStringifier())\n            : safeJsonStringify(value),\n};\n\nexport default T_ARRAY;\n"],"names":["T_ARRAY","name","alias","defaultValue","validate","value","Array","isArray","sanitize","meta","i18n","path","isDone","sanitized","beginSanitize","raw","csv","csvLineParse","delimiter","trimmed","trim","startsWith","endsWith","JSON","parse","elementSchema","schema","map","a","i","Types","padLeft","ValidationError","serialize","typeInfo","arrayToCsv","getStringifier","safeJsonStringify"],"mappings":"oGAsDA,iDAAA,kCAtDgC,iCACwC,gEAE/C,mFACF,qDACC,8GAExB,MAAMA,QAAU,CACZC,KAAM,QACNC,MAAO,CAAC,OAAO,CACfC,aAAc,EAAE,CAChBC,SAAU,AAACC,OAAUC,MAAMC,OAAO,CAACF,OACnCG,SAAU,CAACH,MAAOI,KAAMC,KAAMC,OAAS,CACnC,KAAM,CAACC,OAAQC,UAAU,CAAGC,GAAAA,oBAAa,EAACT,MAAOI,KAAMC,KAAMC,MAC7D,GAAIC,OAAQ,OAAOC,SAAU,CAE7B,MAAME,IAAMV,MAEZ,GAAI,OAAOA,QAAU,SAAU,CAC3B,GAAII,KAAKO,GAAG,CAAE,CACVX,MAAQY,GAAAA,qBAAY,EAACZ,MAAO,CAAEa,UAAWT,KAAKS,SAAS,EAAI,GAAI,EACnE,KAAO,CACH,MAAMC,QAAUd,MAAMe,IAAI,GAC1B,GAAID,QAAQE,UAAU,CAAC,MAAQF,QAAQG,QAAQ,CAAC,KAAM,CAClDjB,MAAQkB,KAAKC,KAAK,CAACL,QACvB,CAAC,AACL,CAAC,AACL,CAAC,AAED,GAAIb,MAAMC,OAAO,CAACF,OAAQ,CACtB,GAAII,KAAKgB,aAAa,CAAE,CACpB,MAAMC,OAAS,OAAOjB,KAAKgB,aAAa,GAAK,WAAahB,KAAKgB,aAAa,GAAKhB,KAAKgB,aAAa,CAEnG,OAAOpB,MAAMsB,GAAG,CAAC,CAACC,EAAGC,IAAMC,YAAK,CAACtB,QAAQ,CAACoB,EAAGF,OAAQhB,KAAMqB,GAAAA,gBAAO,EAAC,CAAC,CAAC,EAAEF,EAAE,CAAC,CAAC,CAAElB,OACjF,CAAC,AAED,OAAON,KACX,CAAC,AAED,MAAM,IAAI2B,uBAAe,CAAC,uBAAwB,CAC9C3B,MAAOU,IACPN,KACAC,KACAC,IACJ,EAAG,AACP,EACAsB,UAAW,CAAC5B,MAAO6B,WACf7B,OAAS,IAAI,CACP,IAAI,CACJ6B,UAAUlB,IACVmB,GAAAA,mBAAU,EAAC9B,MAAO6B,UAAUhB,UAAWkB,GAAAA,qBAAc,KACrDC,GAAAA,wBAAiB,EAAChC,MAAM,AACtC,QAEA,SAAeL"}