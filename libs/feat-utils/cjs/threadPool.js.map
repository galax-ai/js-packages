{"version":3,"sources":["../lib/threadPool.js"],"sourcesContent":["import { Worker } from 'node:worker_threads';\nimport { Feature } from '@galaxar/app';\nimport { InvalidConfiguration } from '@galaxar/types';\nimport Deque from 'collections/deque';\n\nconst recreateWorkerError = (sourceError) => {\n    const error = new Error(sourceError.message);\n\n    for (const [key, value] of Object.entries(sourceError)) {\n        if (key !== 'message') {\n            error[key] = value;\n        }\n    }\n\n    return error;\n};\n\nlet poolIdCounter = 0;\n\nexport class WorkerPool {\n    constructor(app, options) {\n        const { name, workerFile, lowThreadNum, highThreadNum, workerOptions } = options;\n\n        this.app = app;\n        this.workerFile = workerFile;\n        this.lowThreadNum = lowThreadNum;\n        this.highThreadNum = highThreadNum;\n        this.workerOptions = workerOptions;\n        this.poolId = poolIdCounter++;\n        this.name = name ?? `${this.app.name}_tp${this.poolId}`;\n        this.taskIdCounter = 0;\n        this.tasks = new Map();\n        this.idleWorkers = new Deque();\n        this.busyWorkers = new Map();\n\n        if (lowThreadNum > 0) {\n            for (let i = 0; i < lowThreadNum; i++) {\n                this.createWorker(true);\n            }\n        }\n    }\n\n    createWorker(idle) {\n        const worker = new Worker(this.workerFile, this.workerOptions);\n\n        worker.on('message', (message) => {\n            if (message.id === '$CALLBACK') {\n                const { task, payload } = message;\n                const handler = this.handlers?.[task];\n\n                if (handler == null) {\n                    throw new Error(`Unknown callback task \"${task}\".`);\n                }\n\n                Promise.resolve(handler(payload)).catch(this.app.logError);\n            } else {\n                const task = this.tasks.get(message.id);\n                if (task) {\n                    this.tasks.delete(message.id);\n\n                    const workerContext = this.busyWorkers.get(worker.threadId);\n                    workerContext.ongoing--;\n\n                    if (workerContext.ongoing === 0) {\n                        worker.unref();\n                        this.busyWorkers.delete(worker.threadId);\n\n                        if (this.idleWorkers.length < this.lowThreadNum) {\n                            this.idleWorkers.push(worker);\n                        } else {\n                            worker.terminate();\n                        }\n                    }\n\n                    if (message.error == null) {\n                        task.resolve(message.value);\n                    } else {\n                        task.reject(recreateWorkerError(message.error));\n                    }\n                }\n            }\n        });\n\n        worker.on('error', (error) => {\n            // Any error here is effectively an equivalent of segfault, and have no scope, so we just throw it on callback level\n            throw error;\n        });\n\n        if (idle) {\n            this.idleWorkers.push(worker);\n        }\n\n        return worker;\n    }\n\n    getNextWorker() {\n        // If we have idle workers, just use them\n        if (this.idleWorkers.length > 0) {\n            const worker = this.idleWorkers.shift();\n            this.busyWorkers.set(worker.threadId, { ongoing: 1, worker });\n            return worker;\n        }\n\n        // If we have less than highThreadNum workers, create a new one\n        if (this.busyWorkers.size < this.highThreadNum) {\n            const worker = this.createWorker();\n            this.busyWorkers.set(worker.threadId, { ongoing: 1, worker });\n            return worker;\n        }\n\n        // Otherwise, just use the first worker\n        const [workerThreadId, workerContext] = this.busyWorkers.entries().next().value;\n        workerContext.ongoing++;\n        this.busyWorkers.delete(workerThreadId);\n        this.busyWorkers.set(workerThreadId, workerContext);\n        return workerContext.worker;\n    }\n\n    async runTask_(task, payload, transferList) {\n        return new Promise((resolve, reject) => {\n            const taskId = this.taskIdCounter++;\n            this.tasks.set(taskId, { resolve, reject });\n\n            const worker = this.getNextWorker();\n\n            worker.ref();\n            worker.postMessage({ id: taskId, task, payload }, transferList);\n        });\n    }\n\n    setCallbackHandlers(handlers) {\n        this.handlers = { ...this.handlers, ...handlers };\n    }\n}\n\n/**\n * Thread pool to run tasks in parallel\n * @module Feature_ThreadPool\n */\n\nexport default {\n    /**\n     * This feature is loaded at service stage\n     * @member {string}\n     */\n    stage: Feature.SERVICE,\n\n    groupable: true,\n\n    /**\n     * Load the feature\n     * @param {App} app - The app module object\n     * @param {object} [options] - Options for the feature\n     * @returns {Promise.<void>}\n     *\n     */\n    load_: async function (app, options, name) {\n        options = app.featureConfig(\n            options,\n            {\n                schema: {\n                    name: { type: 'text', optional: true },\n                    workerFile: { type: 'text' },\n                    workerOptions: { type: 'object', optional: true },\n                    lowThreadNum: { type: 'integer', default: 0 },\n                    highThreadNum: { type: 'integer', default: 1 },\n                },\n                keepUnsanitized: true,\n            },\n            name\n        );\n\n        const { lowThreadNum, highThreadNum } = options;\n\n        if (highThreadNum < lowThreadNum) {\n            throw new InvalidConfiguration(\n                '\"highThreadNum\" must be greater than or equal to \"lowThreadNum\".',\n                app,\n                `${name}.highThreadNum`\n            );\n        }\n\n        if (highThreadNum === 0) {\n            throw new InvalidConfiguration('\"highThreadNum\" must be greater than 0.', app, `${name}.highThreadNum`);\n        }\n\n        const pool = new WorkerPool(app, options);\n\n        app.registerService(name, pool);\n    },\n};\n"],"names":["WorkerPool","recreateWorkerError","sourceError","error","Error","message","key","value","Object","entries","poolIdCounter","createWorker","idle","worker","Worker","workerFile","workerOptions","on","id","task","payload","handler","handlers","Promise","resolve","catch","app","logError","tasks","get","delete","workerContext","busyWorkers","threadId","ongoing","unref","idleWorkers","length","lowThreadNum","push","terminate","reject","getNextWorker","shift","set","size","highThreadNum","workerThreadId","next","runTask_","transferList","taskId","taskIdCounter","ref","postMessage","setCallbackHandlers","constructor","options","name","poolId","Map","Deque","i","stage","Feature","SERVICE","groupable","load_","featureConfig","schema","type","optional","default","keepUnsanitized","InvalidConfiguration","pool","registerService"],"mappings":"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"}