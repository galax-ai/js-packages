{"version":3,"sources":["../lib/transform.js"],"sourcesContent":["// JSON Expression Syntax (JES)\nimport { get as _get, set as _set } from '@galaxar/utils';\n\nimport _isEmpty from 'lodash/isEmpty';\nimport _reduce from 'lodash/reduce';\nimport _map from 'lodash/map';\nimport _mapValues from 'lodash/mapValues';\n\nimport config, { getChildContext } from './config';\nimport ops from './transformerOperators';\n\nconst MSG = config.messages;\n\nconst PFX_MAP = '|>'; // map\nconst PFX_REDUCE = '|+'; // reduce 1. intermediate = result op [key, value] 2. result = result op intermediate\n\n/**\n * Apply a bianry operator to a value\n * @param {*} value\n * @param {*} op\n * @param {*} opValue\n * @param {*} context\n * @returns {*}\n */\nfunction applyBinaryOperator(value, op, opValue, context) {\n    const handler = config.getTransformer(op);\n\n    if (!handler) {\n        throw new Error(MSG.INVALID_TRANSFORMER_HANDLER(op));\n    }\n\n    return handler(value, opValue, context);\n}\n\n/**\n * Apply an unary operator to a value\n * @param {*} value\n * @param {*} tag\n * @param {*} context\n * @returns {*}\n */\nfunction applyUnaryOperator(value, tag, context) {\n    const handler = config.getTransformer(tag);\n\n    if (!handler) {\n        throw new Error(MSG.INVALID_TRANSFORMER_HANDLER(tag));\n    }\n\n    return handler(value, context);\n}\n\n/**\n * Apply an operator to a value with operator meta\n * @param {*} currentValue\n * @param {*} rightValue\n * @param {*} opMeta\n * @param {*} context\n * @returns {*}\n */\nfunction applyOperator(currentValue, rightValue, [op, isUnary], context) {\n    if (isUnary) {        \n        return applyUnaryOperator(currentValue, op, context);\n    }\n\n    return applyBinaryOperator(currentValue, op, rightValue, context);\n}\n\n/**\n * Apply an collection iteration operator with operator meta\n * @param {*} currentValue\n * @param {*} collectionOp\n * @param {*} opMeta\n * @param {*} expectedFieldValue\n * @param {*} context\n * @returns {*}\n */\nfunction transformCollection(currentValue, collectionOp, opMeta, expectedFieldValue, context) {\n    const isUnary = opMeta[1];\n\n    switch (collectionOp) {\n        case PFX_MAP:\n            return (Array.isArray(currentValue) ? _map : _mapValues)(currentValue, (item, key) =>\n                applyOperator(item, expectedFieldValue, opMeta, getChildContext(context, currentValue, key, item))\n            );\n\n        case PFX_REDUCE:\n            if (\n                !Array.isArray(expectedFieldValue) ||\n                (isUnary && expectedFieldValue.length !== 1)\n            ) {\n                throw new Error(MSG.INVALID_COLLECTION_OP_EXPR(ops.REDUCE, opMeta[0], expectedFieldValue));\n            }\n\n            return _reduce(\n                currentValue,\n                (result, item, key) =>\n                    applyOperator(\n                        result,\n                        expectedFieldValue[1],\n                        opMeta,\n                        getChildContext(context, currentValue, key, item)\n                    ),\n                expectedFieldValue[0]\n            );\n\n        default:\n            throw new Error(MSG.INVALID_COLLECTION_OP(collectionOp));\n    }\n}\n\n/**\n * If $ operator used, only one a time is allowed\n * e.g.\n * {\n *    $groupBy: 'key'\n * }\n *\n *\n * @param {*} currentValue\n * @param {*} jxs\n * @param {*} context\n * @param {boolean} replaceLeft - Whether the expression will replace the left value chain, like a setOp\n * @return {*}\n */\nfunction transform(currentValue, jxs, context, replaceLeft) {\n    if (jxs == null) {\n        return replaceLeft ? jxs : currentValue;\n    }\n\n    if (context == null) {\n        context = {\n            path: null,\n            $$ROOT: currentValue,\n            $$PARENT: null,\n            $$CURRENT: currentValue,\n            $$KEY: null,\n        };\n    }\n\n    if (Array.isArray(jxs)) {\n        if (replaceLeft) {\n            return jxs.map((item) => transform(undefined, item, { ...context }, true));\n        }\n\n        return jxs.reduce((result, exprItem) => transform(result, exprItem, { ...context }), currentValue);\n    }\n\n    const typeExpr = typeof jxs;\n\n    if (typeExpr === 'boolean') {\n        if (replaceLeft) {\n            return jxs;\n        }\n\n        return jxs ? currentValue : undefined;\n    }\n\n    if (typeExpr === 'number' || typeExpr === 'bigint') {\n        if (replaceLeft) {\n            return jxs;\n        }\n\n        throw new Error(MSG.SYNTAX_NUMBER_AS_EXPR);\n    }\n\n    if (typeExpr === 'string') {\n        if (jxs.startsWith('$$')) {\n            //get from context\n            const pos = jxs.indexOf('.');\n            if (pos === -1) {\n                return context[jxs];\n            }\n\n            return _get(context[jxs.substr(0, pos)], jxs.substr(pos + 1));\n        }\n\n        if (replaceLeft) {\n            return jxs;\n        }\n\n        const opMeta = config.getTransformerTagAndType(jxs);\n        if (!opMeta) {\n            throw new Error(MSG.INVALID_TRANSFORMER_OP(jxs));\n        }\n\n        if (!opMeta[1]) {\n            return applyBinaryOperator(currentValue, opMeta[0], null, context);\n        }\n\n        return applyUnaryOperator(currentValue, opMeta[0], context);\n    }\n\n    if (typeExpr !== 'object') {\n        throw new Error(MSG.SYNTAX_INVALID_EXPR(jxs));\n    }\n\n    if (replaceLeft) {\n        return _mapValues(jxs, (item) => transform(undefined, item, context, true));\n    }\n\n    let result,\n        hasOperator = false;\n\n    for (let fieldName in jxs) {\n        let expectedFieldValue = jxs[fieldName];\n\n        const l = fieldName.length;\n\n        if (l > 1) {\n            if (fieldName[0] === '$') {\n                if (result) {\n                    throw new Error(MSG.SYNTAX_OP_NOT_ALONE);\n                }\n\n                const opMeta = config.getTransformerTagAndType(fieldName);\n                if (!opMeta) {\n                    throw new Error(MSG.INVALID_TRANSFORMER_OP(fieldName));\n                }\n\n                if (hasOperator) {\n                    throw new Error(MSG.SYNTAX_OP_NOT_ALONE);\n                }\n\n                result = applyOperator(currentValue, expectedFieldValue, opMeta, context);\n                hasOperator = true;\n                continue;\n            }\n\n            if (l > 3 && fieldName[0] === '|' && fieldName[2] === '$') {\n                if (result) {\n                    throw new Error(MSG.SYNTAX_OP_NOT_ALONE);\n                }\n\n                const collectionOp = fieldName.substring(0, 2);\n                fieldName = fieldName.substring(2);\n\n                const opMeta = config.getTransformerTagAndType(fieldName);\n                if (!opMeta) {\n                    throw new Error(MSG.INVALID_TRANSFORMER_OP(fieldName));\n                }\n\n                if (hasOperator) {\n                    throw new Error(MSG.SYNTAX_OP_NOT_ALONE);\n                }\n\n                result = transformCollection(currentValue, collectionOp, opMeta, expectedFieldValue, context);\n                hasOperator = true;\n                continue;\n            }\n        }\n\n        if (hasOperator) {\n            throw new Error(MSG.SYNTAX_OP_NOT_ALONE);\n        }\n\n        let complexKey = fieldName.indexOf('.') !== -1;\n\n        //pick a field and then apply manipulation\n        let actualFieldValue =\n            currentValue != null ? (complexKey ? _get(currentValue, fieldName) : currentValue[fieldName]) : undefined;\n\n        const childFieldValue = transform(\n            actualFieldValue,\n            expectedFieldValue,\n            getChildContext(context, currentValue, fieldName, actualFieldValue)\n        );\n\n        if (typeof childFieldValue !== 'undefined') {\n            result == null && (result = {});\n            if (complexKey) {\n                _set(result, fieldName, childFieldValue);\n            } else {\n                result[fieldName] = childFieldValue;\n            }\n        }\n    }\n\n    return result;\n}\n\nexport default transform;\n"],"names":["MSG","config","messages","PFX_MAP","PFX_REDUCE","applyBinaryOperator","value","op","opValue","context","handler","getTransformer","Error","INVALID_TRANSFORMER_HANDLER","applyUnaryOperator","tag","applyOperator","currentValue","rightValue","isUnary","transformCollection","collectionOp","opMeta","expectedFieldValue","Array","isArray","_map","_mapValues","item","key","getChildContext","length","INVALID_COLLECTION_OP_EXPR","ops","REDUCE","_reduce","result","INVALID_COLLECTION_OP","transform","jxs","replaceLeft","path","$$ROOT","$$PARENT","$$CURRENT","$$KEY","map","undefined","reduce","exprItem","typeExpr","SYNTAX_NUMBER_AS_EXPR","startsWith","pos","indexOf","_get","substr","getTransformerTagAndType","INVALID_TRANSFORMER_OP","SYNTAX_INVALID_EXPR","hasOperator","fieldName","l","SYNTAX_OP_NOT_ALONE","substring","complexKey","actualFieldValue","childFieldValue","_set"],"mappings":"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"}