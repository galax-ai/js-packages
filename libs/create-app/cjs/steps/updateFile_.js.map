{"version":3,"sources":["../../src/steps/updateFile_.js"],"sourcesContent":["import path from \"node:path\";\nimport { fs } from \"@galaxar/sys\";\nimport { unquote, quote, _ } from \"@galaxar/utils\";\n\nconst fileTypeMapper = {\n    \".npmrc\": \"export\",\n};\n\nfunction parseExports(content) {\n    const lines = content.split(\"\\n\");\n    return lines.reduce((vars, line) => {\n        if (line === \"\") return vars;\n\n        let [key, value] = line.split(\"=\");\n        value = value.trim();\n\n        vars[key.trim()] = unquote(value, true, ['\"', \"'\"]);\n\n        return vars;\n    }, {});\n}\n\nfunction formatExports(vars) {\n    const lines = [];\n\n    _.each(vars, (v, k) => {\n        lines.push(`${k} = ${typeof v === \"string\" ? quote(v) : v}`);\n    });\n\n    return lines.join(\"\\n\") + \"\\n\";\n}\n\nasync function updateFile_(app, targetPath, relativePath, updater) {\n    const filePath = path.resolve(targetPath, relativePath);\n    const baseName = path.basename(relativePath);\n\n    const fileExists = await fs.exists(filePath);\n    const content = fileExists ? await fs.readFile(filePath, \"utf8\") : \"\";\n\n    const fileType = fileTypeMapper[baseName];\n\n    let updated;\n    let noContent = false;\n\n    switch (fileType) {\n        case \"export\":\n            updated = await updater(parseExports(content));\n            noContent = _.isEmpty(updated);\n            updated = formatExports(updated);\n            break;\n\n        case \"json\":\n            updated = await updater(JSON.parse(content));\n            noContent = _.isEmpty(updated);\n            updated = JSON.stringify(updated);\n            break;\n    }\n\n    if (!fileExists && noContent) {\n        return;\n    }\n\n    await fs.writeFile(filePath, updated, \"utf8\");\n    app.log(\"info\", `Updated file ${relativePath}`);\n};\n\nexport default updateFile_;\n"],"names":["fileTypeMapper","parseExports","content","lines","split","reduce","vars","line","key","value","trim","unquote","formatExports","_","each","v","k","push","quote","join","updateFile_","app","targetPath","relativePath","updater","filePath","path","resolve","baseName","basename","fileExists","fs","exists","readFile","fileType","updated","noContent","isEmpty","JSON","parse","stringify","writeFile","log"],"mappings":";;;;+BAkEA;;;eAAA;;;iEAlEiB;qBACE;uBACe;;;;;;AAElC,MAAMA,iBAAiB;IACnB,UAAU;AACd;AAEA,SAASC,aAAaC,OAAO,EAAE;IAC3B,MAAMC,QAAQD,QAAQE,KAAK,CAAC;IAC5B,OAAOD,MAAME,MAAM,CAAC,CAACC,MAAMC,OAAS;QAChC,IAAIA,SAAS,IAAI,OAAOD;QAExB,IAAI,CAACE,KAAKC,MAAM,GAAGF,KAAKH,KAAK,CAAC;QAC9BK,QAAQA,MAAMC,IAAI;QAElBJ,IAAI,CAACE,IAAIE,IAAI,GAAG,GAAGC,IAAAA,cAAO,EAACF,OAAO,IAAI,EAAE;YAAC;YAAK;SAAI;QAElD,OAAOH;IACX,GAAG,CAAC;AACR;AAEA,SAASM,cAAcN,IAAI,EAAE;IACzB,MAAMH,QAAQ,EAAE;IAEhBU,QAAC,CAACC,IAAI,CAACR,MAAM,CAACS,GAAGC,IAAM;QACnBb,MAAMc,IAAI,CAAC,CAAC,EAAED,EAAE,GAAG,EAAE,OAAOD,MAAM,WAAWG,IAAAA,YAAK,EAACH,KAAKA,CAAC,CAAC,CAAC;IAC/D;IAEA,OAAOZ,MAAMgB,IAAI,CAAC,QAAQ;AAC9B;AAEA,eAAeC,YAAYC,GAAG,EAAEC,UAAU,EAAEC,YAAY,EAAEC,OAAO,EAAE;IAC/D,MAAMC,WAAWC,iBAAI,CAACC,OAAO,CAACL,YAAYC;IAC1C,MAAMK,WAAWF,iBAAI,CAACG,QAAQ,CAACN;IAE/B,MAAMO,aAAa,MAAMC,OAAE,CAACC,MAAM,CAACP;IACnC,MAAMvB,UAAU4B,aAAa,MAAMC,OAAE,CAACE,QAAQ,CAACR,UAAU,UAAU,EAAE;IAErE,MAAMS,WAAWlC,cAAc,CAAC4B,SAAS;IAEzC,IAAIO;IACJ,IAAIC,YAAY,KAAK;IAErB,OAAQF;QACJ,KAAK;YACDC,UAAU,MAAMX,QAAQvB,aAAaC;YACrCkC,YAAYvB,QAAC,CAACwB,OAAO,CAACF;YACtBA,UAAUvB,cAAcuB;YACxB,KAAM;QAEV,KAAK;YACDA,UAAU,MAAMX,QAAQc,KAAKC,KAAK,CAACrC;YACnCkC,YAAYvB,QAAC,CAACwB,OAAO,CAACF;YACtBA,UAAUG,KAAKE,SAAS,CAACL;YACzB,KAAM;IACd;IAEA,IAAI,CAACL,cAAcM,WAAW;QAC1B;IACJ,CAAC;IAED,MAAML,OAAE,CAACU,SAAS,CAAChB,UAAUU,SAAS;IACtCd,IAAIqB,GAAG,CAAC,QAAQ,CAAC,aAAa,EAAEnB,aAAa,CAAC;AAClD;;MAEA,WAAeH"}