"use strict";Object.defineProperty(exports,"__esModule",{value:true});const _utils=require("@galaxar/utils");const _types=require("@galaxar/types");const _defaultOpts=require("./defaultOpts");const _logger=require("./logger");function _define_property(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true})}else{obj[key]=value}return obj}const Runnable=T=>{class _class extends T{async start_(){this._initialize();process.on("exit",this._onExit);return super.start_()}async stop_(){if(this.started){if(this.libModules){await (0,_utils.batchAsync_)(this.libModules,lib=>lib.stop_());delete this.libModules}}process.removeListener("exit",this._onExit);await super.stop_();await (0,_utils.sleep_)(0);this._uninitialize()}getLib(libName){if(!this.libModules){throw new Error('"libModules" feature is required to access lib among modules.')}let libModule=this.libModules[libName];if(!libModule){throw new Error(`Lib module [${libName}] not found.`)}return libModule}requireFromLib(libName,relativePath){let libModule=this.getLib(libName);return libModule.require(relativePath)}registerLib(lib){if(!this.libModules){this.libModules={}}if(lib.name in this.libModules){throw new _types.InvalidConfiguration(`Lib module [${lib.name}] already exists.`,this,{name:lib.name})}this.libModules[lib.name]=lib}getService(name){let pos=name.indexOf("/");if(pos===-1){return super.getService(name)}let lib=name.substring(0,pos);name=name.substring(pos+1);let app=this.getLib(lib);return app?.getService(name,true)}resetLogger(){this._injectLogger(true);this._injectLogger()}_initialize(){this._pwd=process.cwd();if(this.workingPath!==this._pwd){process.chdir(this.workingPath)}this._injectLogger();this._injectErrorHandlers()}_uninitialize(){const detach=true;this._injectErrorHandlers(detach);this._injectLogger(detach);process.chdir(this._pwd);delete this._pwd}_injectLogger(detach){if(detach){this.log("verbose","Logger is detaching ...");if(this.logger.close){this.logger.close()}delete this.logger;return}if(this.options.logger){this.logger=this.options.logger}else{(0,_logger.setLogLevel)(this.options.logLevel);this.logger={log:(0,_logger.makeLogger)(_logger.consoleLogger)}}this.log("verbose","Logger injected.")}_injectErrorHandlers(detach){if(detach){process.removeListener("warning",this._onWarning);if(this._onUncaughtException){process.removeListener("uncaughtException",this._onUncaughtException);delete this._onUncaughtException}this.log("verbose","Process-wide error handlers detached.");return}if(!this.options.ignoreUncaught){this._onUncaughtException=this._getOnUncaughtException(this.options.exitOnUncaught);process.on("uncaughtException",this._onUncaughtException)}process.on("warning",this._onWarning);this.log("verbose","Process-wide error handlers injected.")}constructor(name,options){super(name,{..._defaultOpts.defaultAppOpts,...options});_define_property(this,"_getOnUncaughtException",exitOnError=>err=>{if(exitOnError){let waitForLogging=setTimeout(()=>{process.exit(1)},1e3);this.log("error",err,()=>{clearTimeout(waitForLogging);process.exit(1)})}else{this.logError(err)}});_define_property(this,"_onWarning",warning=>{this.log("warn",warning.message)});_define_property(this,"_onExit",code=>{if(this.started){this.stop_().catch(this.logError)}});this.runnable=true;this.libModulesPath=this.toAbsolutePath(this.options.libModulesPath)}}return _class};module.exports=Runnable;
//# sourceMappingURL=Runnable.js.map