{"version":3,"sources":["../../lib/features/libModules.js"],"sourcesContent":["/**\n * Load lib modules\n * @module Feature_LibModules\n *\n * @example\n *\n *  'libModules': {\n *      '<name>': {\n *          npmModule: false, // whether is a npm module\n *          options: { // module options\n *          },\n *          settings: { // can override module defined settings\n *          }\n *      }\n *  }\n */\n\nimport path from 'node:path';\nimport { _, batchAsync_ } from '@galaxar/utils';\nimport { fs, isDir_ } from '@galaxar/sys';\nimport { InvalidConfiguration } from '@genx/types';\nimport Feature from '../Feature';\nimport LibModule from '../LibModule';\n\nexport default {\n    /**\n     * This feature is loaded at plugin stage.\n     * @member {string}\n     */\n    stage: Feature.PLUGIN,\n\n    /**\n     * Load the feature.\n     * @param {App} app - The app module object.\n     * @param {object} entries - Lib module entries.\n     * @returns {Promise.<*>}\n     */\n    load_: async (app, entries) => {\n        return batchAsync_(entries, async (config, name) => {\n            let options = {\n                env: app.env,\n                logLevel: app.options.logLevel,\n                ...config.options,\n            };\n\n            let appPath;\n\n            if (config.npmModule) {\n                appPath = app.toAbsolutePath('node_modules', name);\n            } else {\n                appPath = path.join(app.libModulesPath, name);\n            }\n\n            let exists = (await fs.pathExists(appPath)) && (await isDir_(appPath));\n            if (!exists) {\n                throw new InvalidConfiguration(`Lib [${name}] not exists.`, app, `libModules.${name}`);\n            }\n\n            let lib = new LibModule(app, name, appPath, options);\n\n            lib.on('configLoaded', () => {\n                if (!_.isEmpty(config.settings)) {\n                    lib.config.settings = { ...lib.config.settings, ...config.settings };\n                    app.log('verbose', `Lib settings of [${lib.name}] is overrided.`);\n                }\n            });\n\n            let relativePath = path.relative(app.workingPath, appPath);\n            app.log('verbose', `Loading lib [${lib.name}] from \"${relativePath}\" ...`);\n\n            await lib.start_();\n\n            app.registerLib(lib);\n\n            app.log('verbose', `Lib [${lib.name}] is loaded.`);\n        });\n    },\n};\n"],"names":["stage","Feature","PLUGIN","load_","app","entries","batchAsync_","config","name","options","env","logLevel","appPath","npmModule","toAbsolutePath","path","join","libModulesPath","exists","fs","pathExists","isDir_","InvalidConfiguration","lib","LibModule","on","_","isEmpty","settings","log","relativePath","relative","workingPath","start_","registerLib"],"mappings":"oGAwBA,iDAAA,6DAPiB,mCACc,qCACJ,qCACU,+DACjB,iEACE,2GAEtB,SAAe,CAKXA,MAAOC,gBAAO,CAACC,MAAM,CAQrBC,MAAO,MAAOC,IAAKC,UAAY,CAC3B,MAAOC,GAAAA,kBAAW,EAACD,QAAS,MAAOE,OAAQC,OAAS,CAChD,IAAIC,QAAU,CACVC,IAAKN,IAAIM,GAAG,CACZC,SAAUP,IAAIK,OAAO,CAACE,QAAQ,CAC9B,GAAGJ,OAAOE,OAAO,AACrB,EAEA,IAAIG,QAEJ,GAAIL,OAAOM,SAAS,CAAE,CAClBD,QAAUR,IAAIU,cAAc,CAAC,eAAgBN,KACjD,KAAO,CACHI,QAAUG,iBAAI,CAACC,IAAI,CAACZ,IAAIa,cAAc,CAAET,KAC5C,CAAC,AAED,IAAIU,OAAS,AAAC,MAAMC,OAAE,CAACC,UAAU,CAACR,UAAc,MAAMS,GAAAA,WAAM,EAACT,SAC7D,GAAI,CAACM,OAAQ,CACT,MAAM,IAAII,2BAAoB,CAAC,CAAC,KAAK,EAAEd,KAAK,aAAa,CAAC,CAAEJ,IAAK,CAAC,WAAW,EAAEI,KAAK,CAAC,CAAE,AAC3F,CAAC,AAED,IAAIe,IAAM,IAAIC,kBAAS,CAACpB,IAAKI,KAAMI,QAASH,SAE5Cc,IAAIE,EAAE,CAAC,eAAgB,IAAM,CACzB,GAAI,CAACC,QAAC,CAACC,OAAO,CAACpB,OAAOqB,QAAQ,EAAG,CAC7BL,IAAIhB,MAAM,CAACqB,QAAQ,CAAG,CAAE,GAAGL,IAAIhB,MAAM,CAACqB,QAAQ,CAAE,GAAGrB,OAAOqB,QAAQ,AAAC,EACnExB,IAAIyB,GAAG,CAAC,UAAW,CAAC,iBAAiB,EAAEN,IAAIf,IAAI,CAAC,eAAe,CAAC,CACpE,CAAC,AACL,GAEA,IAAIsB,aAAef,iBAAI,CAACgB,QAAQ,CAAC3B,IAAI4B,WAAW,CAAEpB,SAClDR,IAAIyB,GAAG,CAAC,UAAW,CAAC,aAAa,EAAEN,IAAIf,IAAI,CAAC,QAAQ,EAAEsB,aAAa,KAAK,CAAC,CAEzE,OAAMP,IAAIU,MAAM,GAEhB7B,IAAI8B,WAAW,CAACX,KAEhBnB,IAAIyB,GAAG,CAAC,UAAW,CAAC,KAAK,EAAEN,IAAIf,IAAI,CAAC,YAAY,CAAC,CACrD,EACJ,CACJ"}