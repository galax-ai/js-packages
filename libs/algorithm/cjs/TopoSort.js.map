{"version":3,"sources":["../lib/TopoSort.js"],"sourcesContent":["import { _ } from '@galaxar/utils';\n\n/**\n * @class\n */\nclass TopoSort {\n    /**\n     * Map of nodes to a set of nodes as dependents, <string, Set.<string>>\n     * @member {object}\n     */\n    mapOfDependents = {};\n\n    /** -\n     * Map of nodes to a set of nodes as dependencies, <string, Set.<string>>\n     * @member {object}\n     */\n    mapOfDependencies = {};\n\n    /**\n     * Add edges(or one edge, if values is non-array).\n     * @param {string} dependency - Incoming node (dependency)\n     * @param {string|array} dependents - Outgoing node or nodes\n     */\n    add(dependency, newDependents) {\n        // cast to array\n        newDependents = Array.isArray(newDependents)\n            ? newDependents\n            : [newDependents];\n\n        // get the existing dependents\n        const dependents = this.mapOfDependents[dependency];\n\n        newDependents.forEach((dependent) => {\n            // get the existing dependencies\n            const dependencies = this.mapOfDependencies[dependent];\n            if (!dependencies) {\n                // new set of dependencies\n                this.mapOfDependencies[dependent] = new Set([dependency]);\n            } else {\n                dependencies.add(dependency);\n            }\n\n            if (dependents) {\n                dependents.add(dependent);\n            }\n        });\n\n        if (!dependents) {\n            // new set of dependents\n            this.mapOfDependents[dependency] = new Set(newDependents);\n        }\n    }\n\n    hasDependency(node) {\n        return (\n            (this.mapOfDependencies[node] &&\n                this.mapOfDependencies[node].size > 0) ||\n            false\n        );\n    }\n\n    hasDependent(node) {\n        return (\n            (this.mapOfDependents[node] &&\n                this.mapOfDependents[node].size > 0) ||\n            false\n        );\n    }\n\n    /**\n     * Sort the graph. Circular graph throw an error with the circular nodes info.\n     * Implementation of http://en.wikipedia.org/wiki/Topological_sorting#Algorithms\n     * Reference: http://courses.cs.washington.edu/courses/cse326/03wi/lectures/RaoLect20.pdf\n     * @return {Array} Sorted list\n     */\n    sort() {\n        // The list contains the final sorted nodes.\n        const l = [];\n\n        // Find all the initial 0 incoming edge nodes. If not found, this is is a circular graph, cannot be sorted.\n        const nodesWithDependents = Object.keys(this.mapOfDependents);\n        const nodesWithDependencies = Object.keys(this.mapOfDependencies);\n\n        const initialNodes = new Set(nodesWithDependents);\n        nodesWithDependencies.forEach((nodeHasDependency) =>\n            initialNodes.delete(nodeHasDependency)\n        );\n\n        // List of nodes with no unsorted dependencies\n        const s = [...initialNodes];\n\n        const allNodes = new Set(\n            nodesWithDependents.concat(nodesWithDependencies)\n        );\n\n        // number of unsorted nodes. If it is not zero at the end, this graph is a circular graph and cannot be sorted.\n        let unsorted = allNodes.size;\n\n        const numWithDependencies = _.mapValues(\n            this.mapOfDependencies,\n            (node) => node.size\n        );\n\n        while (s.length !== 0) {\n            const n = s.shift();\n            l.push(n);\n\n            // decrease unsorted count, node n has been sorted.\n            --unsorted;\n\n            // n node might have no dependency, so have to check it.\n            const dependentsOfN = this.mapOfDependents[n];\n            if (dependentsOfN) {\n                // decease n's adjacent nodes' incoming edges count. If any of them has 0 incoming edges, push them into s get them ready for detaching from the graph.\n                for (const dependentOfN of dependentsOfN) {\n                    if (--numWithDependencies[dependentOfN] === 0) {\n                        // no unsorted dependencies\n                        s.push(dependentOfN);\n                    }\n                }\n            }\n        }\n\n        // If there are unsorted nodes left, this graph is a circular graph and cannot be sorted.\n        // At least 1 circular dependency exist in the nodes with non-zero incoming edges.\n        if (unsorted !== 0) {\n            const circular = [];\n\n            for (const node in numWithDependencies) {\n                if (numWithDependencies[node] !== 0) {\n                    circular.push(node);\n                }\n            }\n\n            throw new Error(\n                'At least 1 circular dependency in nodes: \\n\\n' +\n                    circular.join('\\n') +\n                    '\\n\\nGraph cannot be sorted!'\n            );\n        }\n\n        return l;\n    }\n}\n\nexport default TopoSort;\n"],"names":["TopoSort","add","dependency","newDependents","Array","isArray","dependents","mapOfDependents","forEach","dependent","dependencies","mapOfDependencies","Set","hasDependency","node","size","hasDependent","sort","l","nodesWithDependents","Object","keys","nodesWithDependencies","initialNodes","nodeHasDependency","delete","s","allNodes","concat","unsorted","numWithDependencies","_","mapValues","length","n","shift","push","dependentsOfN","dependentOfN","circular","Error","join"],"mappings":"oGAiJA,iDAAA,iCAjJkB,sMAKlB,MAAMA,SAkBFC,IAAIC,UAAU,CAAEC,aAAa,CAAE,CAE3BA,cAAgBC,MAAMC,OAAO,CAACF,eACxBA,cACA,CAACA,cAAc,CAGrB,MAAMG,WAAa,IAAI,CAACC,eAAe,CAACL,WAAW,CAEnDC,cAAcK,OAAO,CAAC,AAACC,WAAc,CAEjC,MAAMC,aAAe,IAAI,CAACC,iBAAiB,CAACF,UAAU,CACtD,GAAI,CAACC,aAAc,CAEf,IAAI,CAACC,iBAAiB,CAACF,UAAU,CAAG,IAAIG,IAAI,CAACV,WAAW,CAC5D,KAAO,CACHQ,aAAaT,GAAG,CAACC,WACrB,CAAC,AAED,GAAII,WAAY,CACZA,WAAWL,GAAG,CAACQ,UACnB,CAAC,AACL,GAEA,GAAI,CAACH,WAAY,CAEb,IAAI,CAACC,eAAe,CAACL,WAAW,CAAG,IAAIU,IAAIT,cAC/C,CAAC,AACL,CAEAU,cAAcC,IAAI,CAAE,CAChB,OACI,AAAC,IAAI,CAACH,iBAAiB,CAACG,KAAK,EACzB,IAAI,CAACH,iBAAiB,CAACG,KAAK,CAACC,IAAI,CAAG,GACxC,KAAK,AAEb,CAEAC,aAAaF,IAAI,CAAE,CACf,OACI,AAAC,IAAI,CAACP,eAAe,CAACO,KAAK,EACvB,IAAI,CAACP,eAAe,CAACO,KAAK,CAACC,IAAI,CAAG,GACtC,KAAK,AAEb,CAQAE,MAAO,CAEH,MAAMC,EAAI,EAAE,CAGZ,MAAMC,oBAAsBC,OAAOC,IAAI,CAAC,IAAI,CAACd,eAAe,EAC5D,MAAMe,sBAAwBF,OAAOC,IAAI,CAAC,IAAI,CAACV,iBAAiB,EAEhE,MAAMY,aAAe,IAAIX,IAAIO,qBAC7BG,sBAAsBd,OAAO,CAAC,AAACgB,mBAC3BD,aAAaE,MAAM,CAACD,oBAIxB,MAAME,EAAI,IAAIH,aAAa,CAE3B,MAAMI,SAAW,IAAIf,IACjBO,oBAAoBS,MAAM,CAACN,wBAI/B,IAAIO,SAAWF,SAASZ,IAAI,CAE5B,MAAMe,oBAAsBC,QAAC,CAACC,SAAS,CACnC,IAAI,CAACrB,iBAAiB,CACtB,AAACG,MAASA,KAAKC,IAAI,EAGvB,MAAOW,EAAEO,MAAM,GAAK,EAAG,CACnB,MAAMC,EAAIR,EAAES,KAAK,GACjBjB,EAAEkB,IAAI,CAACF,EAGP,GAAEL,SAGF,MAAMQ,cAAgB,IAAI,CAAC9B,eAAe,CAAC2B,EAAE,CAC7C,GAAIG,cAAe,CAEf,IAAK,MAAMC,gBAAgBD,cAAe,CACtC,GAAI,EAAEP,mBAAmB,CAACQ,aAAa,GAAK,EAAG,CAE3CZ,EAAEU,IAAI,CAACE,aACX,CAAC,AACL,CACJ,CAAC,AACL,CAIA,GAAIT,WAAa,EAAG,CAChB,MAAMU,SAAW,EAAE,CAEnB,IAAK,MAAMzB,QAAQgB,oBAAqB,CACpC,GAAIA,mBAAmB,CAAChB,KAAK,GAAK,EAAG,CACjCyB,SAASH,IAAI,CAACtB,KAClB,CAAC,AACL,CAEA,MAAM,IAAI0B,MACN,gDACID,SAASE,IAAI,CAAC,MACd,8BACN,AACN,CAAC,AAED,OAAOvB,CACX,eApIAX,sBAAAA,kBAAkB,CAAC,GAMnBI,sBAAAA,oBAAoB,CAAC,GA+HzB,OAEA,SAAeX"}