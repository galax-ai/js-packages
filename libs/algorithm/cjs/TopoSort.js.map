{"version":3,"sources":["../lib/TopoSort.js"],"sourcesContent":["import { _ } from '@galaxar/utils';\n\n/**\n * @class\n */\nclass TopoSort {\n    /**\n     * Map of nodes to a set of nodes as dependents, <string, Set.<string>>\n     * @member {object}\n     */\n    mapOfDependents = {};\n\n    /** -\n     * Map of nodes to a set of nodes as dependencies, <string, Set.<string>>\n     * @member {object}\n     */\n    mapOfDependencies = {};\n\n    /**\n     * Add edges(or one edge, if values is non-array).\n     * @param {string} dependency - Incoming node (dependency)\n     * @param {string|array} dependents - Outgoing node or nodes\n     */\n    add(dependency, newDependents) {\n        // cast to array\n        newDependents = Array.isArray(newDependents) ? newDependents : newDependents == null ? [] : [newDependents];\n\n        // get the existing dependents\n        const dependents = this.mapOfDependents[dependency];\n\n        newDependents.forEach((dependent) => {\n            // get the existing dependencies\n            const dependencies = this.mapOfDependencies[dependent];\n            if (!dependencies) {\n                // new set of dependencies\n                this.mapOfDependencies[dependent] = new Set([dependency]);\n            } else {\n                dependencies.add(dependency);\n            }\n\n            if (dependents) {\n                dependents.add(dependent);\n            }\n        });\n\n        if (!dependents) {\n            // new set of dependents\n            this.mapOfDependents[dependency] = new Set(newDependents);\n        }\n    }\n\n    depends(node, dependencies) {\n        // cast to array\n        dependencies = Array.isArray(dependencies) ? dependencies : dependencies == null ? [] : [dependencies];\n\n        // get the existing dependencies\n        const _dependencies = this.mapOfDependencies[node];\n        if (!_dependencies) {\n            // new set of dependencies\n            this.mapOfDependencies[node] = new Set(dependencies);\n        } else {\n            dependencies.forEach((dependency) => {\n                _dependencies.add(dependency);\n            });\n        }\n\n        // get the existing dependents\n        dependencies.forEach((dependency) => {\n            const dependents = this.mapOfDependents[dependency];\n\n            if (dependents) {\n                dependents.add(node);\n            } else {\n                // new set of dependents\n                this.mapOfDependents[dependency] = new Set([node]);\n            }\n        });\n    }\n\n    hasDependency(node) {\n        return (this.mapOfDependencies[node] && this.mapOfDependencies[node].size > 0) || false;\n    }\n\n    hasDependent(node) {\n        return (this.mapOfDependents[node] && this.mapOfDependents[node].size > 0) || false;\n    }\n\n    /**\n     * Sort the graph. Circular graph throw an error with the circular nodes info.\n     * Implementation of http://en.wikipedia.org/wiki/Topological_sorting#Algorithms\n     * Reference: http://courses.cs.washington.edu/courses/cse326/03wi/lectures/RaoLect20.pdf\n     * @return {Array} Sorted list\n     */\n    sort() {\n        // The list contains the final sorted nodes.\n        const l = [];\n\n        // Find all the initial 0 incoming edge nodes. If not found, this is is a circular graph, cannot be sorted.\n        const nodesWithDependents = Object.keys(this.mapOfDependents);\n        const nodesWithDependencies = Object.keys(this.mapOfDependencies);\n\n        const initialNodes = new Set(nodesWithDependents);\n        nodesWithDependencies.forEach((nodeHasDependency) => initialNodes.delete(nodeHasDependency));\n\n        // List of nodes with no unsorted dependencies\n        const s = [...initialNodes];\n\n        const allNodes = new Set(nodesWithDependents.concat(nodesWithDependencies));\n\n        // number of unsorted nodes. If it is not zero at the end, this graph is a circular graph and cannot be sorted.\n        let unsorted = allNodes.size;\n\n        if (unsorted === 1) {\n            // only 1 node in the graph, no need to sort.\n            return Array.from(allNodes);\n        }\n\n        const numWithDependencies = _.mapValues(this.mapOfDependencies, (node) => node.size);\n\n        console.log({ numWithDependencies, s, allNodes })\n\n        while (s.length !== 0) {\n            const n = s.shift();\n            l.push(n);\n\n            // decrease unsorted count, node n has been sorted.\n            --unsorted;\n\n            // n node might have no dependency, so have to check it.\n            const dependentsOfN = this.mapOfDependents[n];\n            if (dependentsOfN) {\n                // decease n's adjacent nodes' incoming edges count. If any of them has 0 incoming edges, push them into s get them ready for detaching from the graph.\n                for (const dependentOfN of dependentsOfN) {\n                    if (--numWithDependencies[dependentOfN] === 0) {\n                        // no unsorted dependencies\n                        s.push(dependentOfN);\n                    }\n                }\n            }\n        }\n\n        // If there are unsorted nodes left, this graph is a circular graph and cannot be sorted.\n        // At least 1 circular dependency exist in the nodes with non-zero incoming edges.\n        if (unsorted !== 0) {\n            const circular = [];\n\n            for (const node in numWithDependencies) {\n                if (numWithDependencies[node] !== 0) {\n                    circular.push(node);\n                }\n            }\n\n            throw new Error(\n                'At least 1 circular dependency in nodes: \\n\\n' + circular.join('\\n') + '\\n\\nGraph cannot be sorted!'\n            );\n        }\n\n        return l;\n    }\n}\n\nexport default TopoSort;\n"],"names":["TopoSort","add","dependency","newDependents","Array","isArray","dependents","mapOfDependents","forEach","dependent","dependencies","mapOfDependencies","Set","depends","node","_dependencies","hasDependency","size","hasDependent","sort","l","nodesWithDependents","Object","keys","nodesWithDependencies","initialNodes","nodeHasDependency","delete","s","allNodes","concat","unsorted","from","numWithDependencies","_","mapValues","console","log","length","n","shift","push","dependentsOfN","dependentOfN","circular","Error","join"],"mappings":"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"}