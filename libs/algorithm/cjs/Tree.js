"use strict";Object.defineProperty(exports,"__esModule",{value:true});function _export(target,all){for(var name in all)Object.defineProperty(target,name,{enumerable:true,get:all[name]})}_export(exports,{KeyTree:function(){return KeyTree},default:function(){return _default}});const _utils=require("@galaxar/utils");function _define_property(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true})}else{obj[key]=value}return obj}const Tree=Node=>{class _class extends Node{find(predicate){let queue=Node.cloneChildrenList(this);while(queue.length>0){const node=queue.shift();if(predicate(node))return node;queue=queue.concat(Node.cloneChildrenList(node))}return undefined}}_define_property(_class,"Node",Node);return _class};class DataNode{static cloneChildrenList(node){return node.children.concat()}get size(){return this.children.length}append(node){node.parent=this;this.children.push(node)}insert(i,node){node.parent=this;this.children.splice(Math.max(0,i),0,node)}remove(node){if(node.parent!==this){throw new Error("Removing a node which is not a child of the current node.")}this.children=_utils._.reject(this.children,n=>n===node);delete node.parent;return node}removeAtIndex(i){const[removed]=this.children.splice(i,1);if(removed){delete removed.parent}return removed}constructor(data){_define_property(this,"children",[]);this.data=data}}class KeyDataNode{static cloneChildrenList(node){return Object.values(node.children)}get size(){return Object.keys(this.children).length}findByKeyPath(keys){keys=keys.concat();if(keys.length===0||keys[0]!==this.key){return undefined}let value={children:{[this.key]:this}};_utils._.find(keys,key=>{value=value.children[key];return typeof value==="undefined"});return value}appendDataByKeyPath(keys,data){keys=keys.concat();if(keys.length===0||keys[0]!==this.key){throw new Error(`The given key path "${keys.join(" / ")}" is not starting from the correct initial key "${this.key}".`)}const lastKey=keys.pop();let lastNode={children:{[this.key]:this}};let node;_utils._.each(keys,key=>{if(key in lastNode.children){lastNode=lastNode.children[key]}else{node=new KeyDataNode(key);lastNode.append(node);lastNode=node}});node=new KeyDataNode(lastKey,data);lastNode.append(node);return node}append(node){node.parent=this;if(node.key in this.children){throw new Error(`Duplicate node key: ${node.key}`)}this.children[node.key]=node}remove(node){if(node.parent!==this||!(node.key in this.children)){throw new Error("Removing a node which is not a child of the current node.")}delete this.children[node.key];delete node.parent;return node}getKeyPath(){const paths=[this.key];let curr=this;while(curr.parent){curr=curr.parent;paths.push(curr.key)}return paths.reverse()}constructor(key,data){_define_property(this,"children",{});this.key=key;this.data=data}}const KeyTree=Tree(KeyDataNode);const _default=Tree(DataNode);
//# sourceMappingURL=Tree.js.map