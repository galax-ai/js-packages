{"version":3,"sources":["../lib/Search.js"],"sourcesContent":["/**\n * Perform a breadth-first search on a graph or tree.\n * @param {Object} root - The root node to start the search from.\n * @param {Function} visit - A function to call for each visited node, return true to end up the search.\n * @param {Function} getChildren - A function to get the children of a node.\n * @returns {Object} The node found\n */\nexport function bfs(root, visit, getChildren) {\n    const queue = Array.isArray(root) ? [...root] : [root];\n    const visited = new Set();\n    visited.add(root);\n\n    let found;\n\n    while (queue.length > 0) {\n        const node = queue.shift();\n        if (visit(node)) {\n            found = node;\n            break;\n        }\n\n        const children = getChildren(node);\n        children?.forEach((child) => {\n            if (!visited.has(child)) {\n                visited.add(child);\n                queue.push(child);\n            }\n        });\n    }\n\n    return found;\n}\n\n/**\n * Perform a depth-first search on a graph or tree.\n * @param {Object} root - The root node to start the search from.\n * @param {Function} visit - A function to call for each visited node, return true to end up the search.\n * @param {Function} getChildren - A function to get the children of a node.\n * @returns {Object} The node found\n */\nexport function dfs(root, visit, getChildren) {\n    const stack = Array.isArray(root) ? [...root].reverse() : [root];\n    const visited = new Set();\n\n    let found;\n\n    while (stack.length > 0) {\n        const node = stack.pop();\n\n        if (!visited.has(node)) {\n            if (visit(node)) {\n                found = node;\n                break;\n            }\n            visited.add(node);\n\n            const children = getChildren(node);\n            if (!children || children.length === 0) {\n                continue;\n            }\n\n            const [ leftNode, ...right ] = children;            \n\n            right.reverse().forEach((child) => {\n                stack.push(child);\n            });\n\n            stack.push(leftNode);\n        }\n    }\n\n    return found;\n}"],"names":["bfs","dfs","root","visit","getChildren","queue","Array","isArray","visited","Set","add","found","length","node","shift","children","forEach","child","has","push","stack","reverse","pop","leftNode","right"],"mappings":"2MAOgBA,GAAG,mBAAHA,KAiCAC,GAAG,mBAAHA,OAjCT,SAASD,IAAIE,IAAI,CAAEC,KAAK,CAAEC,WAAW,CAAE,CAC1C,MAAMC,MAAQC,MAAMC,OAAO,CAACL,MAAQ,IAAIA,KAAK,CAAG,CAACA,KAAK,CACtD,MAAMM,QAAU,IAAIC,IACpBD,QAAQE,GAAG,CAACR,MAEZ,IAAIS,MAEJ,MAAON,MAAMO,MAAM,CAAG,EAAG,CACrB,MAAMC,KAAOR,MAAMS,KAAK,GACxB,GAAIX,MAAMU,MAAO,CACbF,MAAQE,KACR,KAAM,AACV,CAAC,AAED,MAAME,SAAWX,YAAYS,MAC7BE,UAAUC,QAAQ,AAACC,OAAU,CACzB,GAAI,CAACT,QAAQU,GAAG,CAACD,OAAQ,CACrBT,QAAQE,GAAG,CAACO,OACZZ,MAAMc,IAAI,CAACF,MACf,CAAC,AACL,EACJ,CAEA,OAAON,KACX,CASO,SAASV,IAAIC,IAAI,CAAEC,KAAK,CAAEC,WAAW,CAAE,CAC1C,MAAMgB,MAAQd,MAAMC,OAAO,CAACL,MAAQ,IAAIA,KAAK,CAACmB,OAAO,GAAK,CAACnB,KAAK,CAChE,MAAMM,QAAU,IAAIC,IAEpB,IAAIE,MAEJ,MAAOS,MAAMR,MAAM,CAAG,EAAG,CACrB,MAAMC,KAAOO,MAAME,GAAG,GAEtB,GAAI,CAACd,QAAQU,GAAG,CAACL,MAAO,CACpB,GAAIV,MAAMU,MAAO,CACbF,MAAQE,KACR,KAAM,AACV,CAAC,AACDL,QAAQE,GAAG,CAACG,MAEZ,MAAME,SAAWX,YAAYS,MAC7B,GAAI,CAACE,UAAYA,SAASH,MAAM,GAAK,EAAG,CACpC,QAAS,AACb,CAAC,AAED,KAAM,CAAEW,SAAU,GAAGC,MAAO,CAAGT,SAE/BS,MAAMH,OAAO,GAAGL,OAAO,CAAC,AAACC,OAAU,CAC/BG,MAAMD,IAAI,CAACF,MACf,GAEAG,MAAMD,IAAI,CAACI,SACf,CAAC,AACL,CAEA,OAAOZ,KACX"}