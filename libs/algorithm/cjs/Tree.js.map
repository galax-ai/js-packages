{"version":3,"sources":["../lib/Tree.js"],"sourcesContent":["import { _ } from '@galaxar/utils';\n\n/**\n * A closure function to be called to check the data of each node whether meets certain condition\n * @callback predicateFunction\n * @param {Node} node\n * @returns {boolean}\n */\n\n/**\n * Tree factory.\n * @param {Node} Node\n * @returns {Tree}\n */\nconst Tree = (Node) =>\n    class extends Node {\n        static Node = Node;\n\n        /**\n         * Find a node by BFS.\n         * @param {predicateFunction} predicate\n         */\n        find(predicate) {\n            let queue = Node.cloneChildrenList(this);\n\n            while (queue.length > 0) {\n                const node = queue.shift();\n\n                if (predicate(node)) return node;\n\n                queue = queue.concat(Node.cloneChildrenList(node));\n            }\n\n            return undefined;\n        }\n    };\n\n/**\n * Tree node with data property.\n * @class\n */\nclass DataNode {\n    static cloneChildrenList(node) {\n        return node.children.concat();\n    }\n\n    /**\n     * Array of children nodes.\n     * @member {array}\n     */\n    children = [];\n\n    /**\n     * Create a data node with given data.\n     * @param {*} data\n     */\n    constructor(data) {\n        /**\n         * Data property.\n         * @member {*}\n         */\n        this.data = data;\n    }\n\n    /**\n     * Number of nodes.\n     * @member {number}\n     */\n    get size() {\n        return this.children.length;\n    }\n\n    /**\n     * Append the given node to the end of the children list.\n     * @param {DataNode} node\n     */\n    append(node) {\n        node.parent = this;\n        this.children.push(node);\n    }\n\n    /**\n     * Insert the given node at specified index in the children list.\n     * @param {number} i\n     * @param {DataNode} node\n     */\n    insert(i, node) {\n        node.parent = this;\n        this.children.splice(Math.max(0, i), 0, node);\n    }\n\n    /**\n     * Remove the given node from the branch.\n     * @param {DataNode} node\n     * @returns {DataNode}\n     */\n    remove(node) {\n        if (node.parent !== this) {\n            throw new Error('Removing a node which is not a child of the current node.');\n        }\n\n        this.children = _.reject(this.children, (n) => n === node);\n        delete node.parent;\n\n        return node;\n    }\n\n    /**\n     * Remove the node at the given index from the branch.\n     * @param {number} i\n     * @returns {DataNode}\n     */\n    removeAtIndex(i) {\n        const [removed] = this.children.splice(i, 1);\n        if (removed) {\n            delete removed.parent;\n        }\n\n        return removed;\n    }\n}\n\n/**\n * Tree node with key property and data property.\n * @class\n */\nclass KeyDataNode {\n    static cloneChildrenList(node) {\n        return Object.values(node.children);\n    }\n\n    /**\n     * Map of keys to children nodes.\n     * @member {object}\n     */\n    children = {};\n\n    /**\n     * Create a key-data node with key and given data.\n     * @param {string} key\n     * @param {*} data\n     */\n    constructor(key, data) {\n        /**\n         * Node key.\n         * @member {string}\n         */\n        this.key = key;\n\n        /**\n         * Data property.\n         * @member {*}\n         */\n        this.data = data;\n    }\n\n    /**\n     * Number of nodes.\n     * @member {number}\n     */\n    get size() {\n        return Object.keys(this.children).length;\n    }\n\n    /**\n     * Fina a node by path being an array of keys.\n     * @param {array.<string>} keys\n     */\n    findByKeyPath(keys) {\n        keys = keys.concat();\n\n        if (keys.length === 0 || keys[0] !== this.key) {\n            return undefined;\n        }\n\n        let value = { children: { [this.key]: this } };\n\n        _.find(keys, (key) => {\n            value = value.children[key];\n            return typeof value === 'undefined';\n        });\n\n        return value;\n    }\n\n    /**\n     * Append data by path being an array of keys.\n     * @param {array.<string>} keys\n     * @param {*} data\n     * @returns {KeyDataNode} The newly created node containing the data.\n     */\n    appendDataByKeyPath(keys, data) {\n        keys = keys.concat();\n\n        if (keys.length === 0 || keys[0] !== this.key) {\n            throw new Error(\n                `The given key path \"${keys.join(' / ')}\" is not starting from the correct initial key \"${this.key}\".`\n            );\n        }\n\n        const lastKey = keys.pop();\n        let lastNode = { children: { [this.key]: this } };\n        let node;\n\n        _.each(keys, (key) => {\n            if (key in lastNode.children) {\n                lastNode = lastNode.children[key];\n            } else {\n                node = new KeyDataNode(key);\n                lastNode.append(node);\n                lastNode = node;\n            }\n        });\n\n        node = new KeyDataNode(lastKey, data);\n        lastNode.append(node);\n\n        return node;\n    }\n\n    /**\n     * Append the given node to the end of the children list.\n     * @param {KeyDataNode} node\n     */\n    append(node) {\n        node.parent = this;\n\n        if (node.key in this.children) {\n            throw new Error(`Duplicate node key: ${node.key}`);\n        }\n\n        this.children[node.key] = node;\n    }\n\n    /**\n     * Remove the given node from the branch.\n     * @param {KeyDataNode} node\n     */\n    remove(node) {\n        if (node.parent !== this || !(node.key in this.children)) {\n            throw new Error('Removing a node which is not a child of the current node.');\n        }\n\n        delete this.children[node.key];\n        delete node.parent;\n\n        return node;\n    }\n\n    /**\n     * Get key path of current node (a key chain from root to itself).\n     * @returns {array}\n     */\n    getKeyPath() {\n        const paths = [this.key];\n        let curr = this;\n\n        while (curr.parent) {\n            curr = curr.parent;\n            paths.push(curr.key);\n        }\n\n        return paths.reverse();\n    }\n}\n\nexport const KeyTree = Tree(KeyDataNode);\n\nexport default Tree(DataNode);\n"],"names":["KeyTree","Tree","Node","find","predicate","queue","cloneChildrenList","length","node","shift","concat","undefined","DataNode","children","size","append","parent","push","insert","i","splice","Math","max","remove","Error","_","reject","n","removeAtIndex","removed","constructor","data","KeyDataNode","Object","values","keys","findByKeyPath","key","value","appendDataByKeyPath","join","lastKey","pop","lastNode","each","getKeyPath","paths","curr","reverse"],"mappings":"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"}