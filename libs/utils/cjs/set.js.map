{"version":3,"sources":["../set.js"],"sourcesContent":["import isPlainObject from './isPlainObject';\nimport _each from 'lodash/each';\nimport isInteger, { RANGE_INDEX } from './isInteger';\n\n// attention: since mobx will wrap the object in a Proxy, the source value will be different from the wrapped one\n// Here must return the obj[index] of obj[key], otherwise the child node will not be mounted to the root object\n\nexport const addEntry = (obj, key, value, numberAsArrayIndex) => {\n    if (numberAsArrayIndex && isInteger(key, { range: RANGE_INDEX })) {\n        if (Array.isArray(obj)) {\n            const index = parseInt(key, 10);\n\n            if (obj.length <= index) {\n                const numToFill = index - obj.length;\n                if (numToFill > 0) {\n                    for (let i = 0; i < numToFill; i++) {\n                        obj.push(undefined);\n                    }\n                }\n\n                obj.push(value);\n            } else {\n                obj[index] = value;\n            }\n\n            return obj[index];\n        }\n    }\n\n    obj[key] = value;\n    return obj[key];\n};\n\n/**\n * Set a value by dot-separated path or key array into a collection\n * Does not support '[i]', e.g. 'a[0].b.c' style accessor, use [ 'a',  0, 'b', 'c' ] instead, different from lodash/set\n * @alias  object.set\n * @param {Object} collection - The collection\n * @param {string} keyPath - A dot-separated path (dsp) or a key array, e.g. settings.xxx.yyy, or ['setting', 'xxx', 'yyy']\n * @param {Object} value - The default value if the path does not exist\n * @returns {*}\n */\nconst _set = (collection, keyPath, value, options) => {\n    options = { numberAsArrayIndex: true, keyPathSeparator: '.', ...options };\n\n    if (collection == null || typeof collection !== 'object') {\n        return collection;\n    }\n\n    if (keyPath == null) {\n        return collection;\n    }\n\n    if (isPlainObject(keyPath) && typeof value === 'undefined') {\n        // extract all key value pair and set\n        _each(keyPath, (v, k) => _set(collection, k, v, options));\n        return collection;\n    }\n\n    // break the path into nodes array\n    let nodes = Array.isArray(keyPath) ? keyPath.concat() : keyPath.split(options.keyPathSeparator);\n    const length = nodes.length;\n\n    if (length > 0) {\n        const lastIndex = length - 1;\n\n        let index = 0;\n        let nested = collection;\n\n        while (nested != null && index < lastIndex) {\n            const key = nodes[index++];\n\n            let next = nested[key];\n            if (next == null || typeof next !== 'object') {\n                // peek next node, see if it is integer\n                const nextKey = nodes[index];\n\n                if (options.numberAsArrayIndex && isInteger(nextKey, { range: RANGE_INDEX })) {\n                    next = addEntry(nested, key, [], options.numberAsArrayIndex);\n                } else {\n                    next = addEntry(nested, key, {}, options.numberAsArrayIndex);\n                }\n            }\n\n            nested = next;\n        }\n\n        const lastKey = nodes[lastIndex];\n        addEntry(nested, lastKey, value, options.numberAsArrayIndex);\n    }\n\n    return collection;\n};\n\nexport default _set;\n"],"names":["addEntry","obj","key","value","numberAsArrayIndex","isInteger","range","RANGE_INDEX","Array","isArray","index","parseInt","length","numToFill","i","push","undefined","_set","collection","keyPath","options","keyPathSeparator","isPlainObject","_each","v","k","nodes","concat","split","lastIndex","nested","next","nextKey","lastKey"],"mappings":"2MAOaA,QAAQ,mBAARA,UAuFb,OAAoB,mBAApB,kEA9F0B,iEACR,mEACqB,0jCAKhC,MAAMA,SAAW,CAACC,IAAKC,IAAKC,MAAOC,qBAAuB,CAC7D,GAAIA,oBAAsBC,GAAAA,kBAAS,EAACH,IAAK,CAAEI,MAAOC,sBAAW,AAAC,GAAI,CAC9D,GAAIC,MAAMC,OAAO,CAACR,KAAM,CACpB,MAAMS,MAAQC,SAAST,IAAK,IAE5B,GAAID,IAAIW,MAAM,EAAIF,MAAO,CACrB,MAAMG,UAAYH,MAAQT,IAAIW,MAAM,CACpC,GAAIC,UAAY,EAAG,CACf,IAAK,IAAIC,EAAI,EAAGA,EAAID,UAAWC,IAAK,CAChCb,IAAIc,IAAI,CAACC,UACb,CACJ,CAAC,AAEDf,IAAIc,IAAI,CAACZ,MACb,KAAO,CACHF,GAAG,CAACS,MAAM,CAAGP,KACjB,CAAC,AAED,OAAOF,GAAG,CAACS,MAAM,AACrB,CAAC,AACL,CAAC,AAEDT,GAAG,CAACC,IAAI,CAAGC,MACX,OAAOF,GAAG,CAACC,IAAI,AACnB,EAWA,MAAMe,KAAO,CAACC,WAAYC,QAAShB,MAAOiB,UAAY,CAClDA,QAAU,CAAEhB,mBAAoB,IAAI,CAAEiB,iBAAkB,IAAK,GAAGD,OAAO,AAAC,EAExE,GAAIF,YAAc,IAAI,EAAI,OAAOA,aAAe,SAAU,CACtD,OAAOA,UACX,CAAC,AAED,GAAIC,SAAW,IAAI,CAAE,CACjB,OAAOD,UACX,CAAC,AAED,GAAII,GAAAA,sBAAa,EAACH,UAAY,OAAOhB,QAAU,YAAa,CAExDoB,GAAAA,aAAK,EAACJ,QAAS,CAACK,EAAGC,IAAMR,KAAKC,WAAYO,EAAGD,EAAGJ,UAChD,OAAOF,UACX,CAAC,AAGD,IAAIQ,MAAQlB,MAAMC,OAAO,CAACU,SAAWA,QAAQQ,MAAM,GAAKR,QAAQS,KAAK,CAACR,QAAQC,gBAAgB,CAAC,CAC/F,MAAMT,OAASc,MAAMd,MAAM,CAE3B,GAAIA,OAAS,EAAG,CACZ,MAAMiB,UAAYjB,OAAS,EAE3B,IAAIF,MAAQ,EACZ,IAAIoB,OAASZ,WAEb,MAAOY,QAAU,IAAI,EAAIpB,MAAQmB,UAAW,CACxC,MAAM3B,IAAMwB,KAAK,CAAChB,QAAQ,CAE1B,IAAIqB,KAAOD,MAAM,CAAC5B,IAAI,CACtB,GAAI6B,MAAQ,IAAI,EAAI,OAAOA,OAAS,SAAU,CAE1C,MAAMC,QAAUN,KAAK,CAAChB,MAAM,CAE5B,GAAIU,QAAQhB,kBAAkB,EAAIC,GAAAA,kBAAS,EAAC2B,QAAS,CAAE1B,MAAOC,sBAAW,AAAC,GAAI,CAC1EwB,KAAO/B,SAAS8B,OAAQ5B,IAAK,EAAE,CAAEkB,QAAQhB,kBAAkB,CAC/D,KAAO,CACH2B,KAAO/B,SAAS8B,OAAQ5B,IAAK,CAAC,EAAGkB,QAAQhB,kBAAkB,CAC/D,CAAC,AACL,CAAC,AAED0B,OAASC,IACb,CAEA,MAAME,QAAUP,KAAK,CAACG,UAAU,CAChC7B,SAAS8B,OAAQG,QAAS9B,MAAOiB,QAAQhB,kBAAkB,CAC/D,CAAC,AAED,OAAOc,UACX,QAEA,SAAeD"}