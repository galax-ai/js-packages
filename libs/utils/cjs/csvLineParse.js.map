{"version":3,"sources":["../csvLineParse.js"],"sourcesContent":["import replaceAll from './replaceAll';\n\n/**\n * Parse csv string into array, simple implementation especially for one-line parsing.\n * 23x faster than csv-parse for single line parsing\n * 10x faster than csv-parse/sync for single line parsing\n *\n * split + simpleCsvParser, however split('\\n') is not good for massive data, should use stream reader instead\n * 5x faster than csv-parse/sync for multiple lines parsing\n *\n * @param {string} str\n * @param {object} [options]\n * @property {string} [options.delimiter=',']\n * @property {boolean} [options.emptyAsNull=false]\n * @returns {array}\n */\nconst simpleCsvParser = (str, options) => {\n    const { delimiter, emptyAsNull } = { delimiter: ',', emptyAsNull: false, ...options };\n\n    let inQuote = null;\n    let start = 0;\n    let result = [];\n    let lastWord = null;\n    let hasEscaped = false;\n\n    const l = str.length;\n\n    for (let i = 0; i < l; i++) {\n        const ch = str[i];\n\n        if (inQuote) {\n            if (ch === inQuote) {\n                if (str[i - 1] === '\\\\') {\n                    hasEscaped = true;\n                } else {\n                    // not escaped\n                    lastWord = str.substring(start, i);\n                    if (lastWord && hasEscaped) {\n                        lastWord = replaceAll(lastWord, '\\\\' + inQuote, inQuote);\n                    }\n                    inQuote = null;\n                    hasEscaped = false;\n                }\n            }\n        } else if (ch === delimiter) {\n            if (lastWord == null && i > start) {\n                lastWord = str.substring(start, i);\n            }\n            result.push(lastWord ? lastWord.trim() : emptyAsNull ? null : '');\n            lastWord = null;\n            hasEscaped = false;\n            start = i + 1;\n        } else if (ch === '\"' || ch === \"'\") {\n            if (lastWord == null) {\n                inQuote = ch;\n                start = i + 1;\n            }\n        }\n    }\n\n    if (lastWord == null) {\n        lastWord = str.substring(start);\n    }\n    result.push(lastWord ? lastWord.trim() : emptyAsNull ? null : '');\n\n    return result;\n};\n\nexport default simpleCsvParser;\n"],"names":["simpleCsvParser","str","options","delimiter","emptyAsNull","inQuote","start","result","lastWord","hasEscaped","l","length","i","ch","substring","replaceAll","push","trim"],"mappings":"oGAoEA,iDAAA,+DApEuB,qGAgBvB,MAAMA,gBAAkB,CAACC,IAAKC,UAAY,CACtC,KAAM,CAAEC,SAAS,CAAEC,WAAW,CAAE,CAAG,CAAED,UAAW,IAAKC,YAAa,KAAK,CAAE,GAAGF,OAAO,AAAC,EAEpF,IAAIG,QAAU,IAAI,CAClB,IAAIC,MAAQ,EACZ,IAAIC,OAAS,EAAE,CACf,IAAIC,SAAW,IAAI,CACnB,IAAIC,WAAa,KAAK,CAEtB,MAAMC,EAAIT,IAAIU,MAAM,CAEpB,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAGE,IAAK,CACxB,MAAMC,GAAKZ,GAAG,CAACW,EAAE,CAEjB,GAAIP,QAAS,CACT,GAAIQ,KAAOR,QAAS,CAChB,GAAIJ,GAAG,CAACW,EAAI,EAAE,GAAK,KAAM,CACrBH,WAAa,IAAI,AACrB,KAAO,CAEHD,SAAWP,IAAIa,SAAS,CAACR,MAAOM,GAChC,GAAIJ,UAAYC,WAAY,CACxBD,SAAWO,GAAAA,mBAAU,EAACP,SAAU,KAAOH,QAASA,QACpD,CAAC,AACDA,QAAU,IAAI,CACdI,WAAa,KAAK,AACtB,CAAC,AACL,CAAC,AACL,MAAO,GAAII,KAAOV,UAAW,CACzB,GAAIK,UAAY,IAAI,EAAII,EAAIN,MAAO,CAC/BE,SAAWP,IAAIa,SAAS,CAACR,MAAOM,EACpC,CAAC,AACDL,OAAOS,IAAI,CAACR,SAAWA,SAASS,IAAI,GAAKb,YAAc,IAAI,CAAG,EAAE,EAChEI,SAAW,IAAI,CACfC,WAAa,KAAK,CAClBH,MAAQM,EAAI,CAChB,MAAO,GAAIC,KAAO,KAAOA,KAAO,IAAK,CACjC,GAAIL,UAAY,IAAI,CAAE,CAClBH,QAAUQ,GACVP,MAAQM,EAAI,CAChB,CAAC,AACL,CAAC,AACL,CAEA,GAAIJ,UAAY,IAAI,CAAE,CAClBA,SAAWP,IAAIa,SAAS,CAACR,MAC7B,CAAC,AACDC,OAAOS,IAAI,CAACR,SAAWA,SAASS,IAAI,GAAKb,YAAc,IAAI,CAAG,EAAE,EAEhE,OAAOG,MACX,QAEA,SAAeP"}